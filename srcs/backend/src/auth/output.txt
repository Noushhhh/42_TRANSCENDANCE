   
//component in react

// Importing necessary hooks and components from "react-router-dom".
import { useNavigate } from "react-router-dom";
import { useSignOut } from "./useSignOut";
import { useEffect, useCallback } from "react";
import Cookies from 'js-cookie';

// ─────────────────────────────────────────────────────────────────────────────

/**
 * @brief Refreshes the user's access token.
 * @throws Error if the token refresh request fails.
 */
const refreshToken = async () => {
  try {
    const response = await fetch('http://localhost:8081/api/auth/refreshToken', {
      method: 'POST',
      credentials: 'include', // Send cookies with the request
    });
    if (!response.ok) {
      throw new Error('Failed to refresh token');
    }
  } catch (error) {
    console.error('Error refreshing token:', error);
  }
};

// ─────────────────────────────────────────────────────────────────────────────

/**
 * @file useActivityLogout.tsx
 * @author [Jairo Alexander VALENCIA CANDAMIL]
 * @date 2023-10-21
 * 
 * @brief This is a custom React hook that handles user inactivity.
 * It logs out the user after a certain period of inactivity and navigates to the sign-in page.
 * 
 * @note The inactivity period is currently set to 120000 milliseconds (2 minutes).
 */


/**
 * @function useActivityLogout
 * @description This hook sets up event listeners for user activity and logs out the user after a period of inactivity.
 * @returns {null} This hook does not return anything.
 */
const useActivityLogout = () => {
    const navigate = useNavigate();
    const handleSignOut = useSignOut();
    let inactivityTimer: any;

    // Function to handle user sign out and navigation to the sign-in page.
    const logoutAndNavigate = useCallback(() => {
        handleSignOut();
        navigate('signin');
    }, [handleSignOut, navigate]);

    // Function to reset the inactivity timer.
    const resetTimer = useCallback(() => {
        clearTimeout(inactivityTimer);

        //Extract token Expiration date from cookies, is the only information we only can extract for security
        const tokenExpires = Cookies.get('tokenExpires');
        if (!tokenExpires) {
            console.warn('Token expiration time not found in cookie');
            return;
        }

        // Convert expiration data to date
        const accessTokenExpiresAt = new Date(tokenExpires);
        const now = new Date().getTime();
        // Calculate the expiration token time in milliseconds
        const expiresIn: number = accessTokenExpiresAt.getTime() - now;

        // If the token expires within 5 minutes, we create a new token
        if (expiresIn <= 5 * 60 * 1000) {
            refreshToken().catch((error) => {
                console.error('Error refreshing token:', error);
            });
        }

        inactivityTimer = setTimeout(logoutAndNavigate, 6000000);
    }, [logoutAndNavigate]);

    // Function to handle window close event.
    const handleWindowClose = useCallback(() => {
        handleSignOut();
    }, [handleSignOut]);

    // Setting up event listeners for user activity and window close.
    useEffect(() => {
        window.addEventListener('load', resetTimer);
        window.addEventListener('mousemove', resetTimer);
        window.addEventListener('keypress', resetTimer);
        window.addEventListener('beforeunload', handleWindowClose);

        // Cleaning up event listeners on unmount.
        return () => {
            window.removeEventListener('load', resetTimer);
            window.removeEventListener('mousemove', resetTimer);
            window.removeEventListener('keypress', resetTimer);
            window.removeEventListener('beforeunload', handleWindowClose);
        };
    }, [resetTimer, handleWindowClose]);

    return null;
};

// Export the hook for use in other components.
export default useActivityLogout; 

-- ─────────────────────────────────────────────────────────────────────────────


    //controller to implement

    @Post('refreshToken')
    async refreshToken(@ExtractJwt() decodedPayload: DecodedPayload | null, @Res() res: Response): Promise<Response> {
        try {
        if (!decodedPayload) {
          //do something, or do whatever you think is the proper thing
        }
          const result: any = await this.authService.signToken(decodedPayload.sub, decodedPayload.email, res);
          return res.status(result.statusCode).send({ valid: result.valid, message: result.message });
        } catch (error) {
          console.error('Error in refreshToken controller:', error);
          return res.status(500).send({ message: 'Internal server error' });
        }
      }


// service used by the controller
/**
 * @brief This function signs a token.
 * @param userId The user's ID.
 * @param username The user's username.
 * @param res The response object.
 * @return A promise that resolves to void.
 */
async signToken(userId: number, email: string, res: Response): Promise<any> {
  const { token, refreshToken } = await this.generateAndSetTokens(userId, email, res);

  if (!refreshToken) {
      return ({
          statusCode: 409,
          valid: false,
          message: "Problem creating refresh token"
      });
  }

  // Decode the token to get the expiration time
  const decodedToken = jwt.verify(token, this.JWT_SECRET);

  if (typeof decodedToken === 'object' && 'exp' in decodedToken) {
      // Set the tokenExpires cookie with the decoded expiration time
      res.cookie('tokenExpires', new Date((decodedToken as { exp: number }).exp * 1000).toISOString(), {
          secure: true,
          sameSite: 'strict',
          maxAge: 1000 * 60 * 15
      });
  } else {
      return ({
          statusCode: 409,
          valid: false,
          message: "Impossible to decode token to create expiration time"
      });
  }
  return ({
      statusCode: 200,
      valid: true,
      message: "Authentication successful"
  });
}

// functions used by the service
/**
 * @brief This function generates and sets JWT and refresh tokens for a user.
 * @param userId The user's ID.
 * @param email The user's email.
 * @param res The response object.
 * @return An object containing the JWT token and the refresh token.
 */
async generateAndSetTokens(userId: number, email: string, res: Response): Promise<{ token: string, refreshToken: { token: string, expiresAt: Date } }> {
  // Define the payload for the JWT token
  const payload = {
    sub: userId,
    email,
  };
  const secret = this.JWT_SECRET;

  // Generate the JWT token
  const token = await this.jwt.signAsync(
    payload,
    {
      expiresIn: '15m', // The JWT token expires in 15 minutes
      secret: secret,
    },
  );

  // Get or create a refresh token for the user
  const refreshToken = await this.refreshTokenIfNeeded(userId);

  // If a refresh token is obtained, set it in a HttpOnly cookie
  if (refreshToken) {
    res.cookie('refreshToken', refreshToken.token, {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      maxAge: (refreshToken.expiresAt.getTime() - Date.now()) // The cookie expires when the refresh token expires
    });
  }

  // Set the JWT token in a HttpOnly cookie
  res.cookie('token', token, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 1000 * 60 * 15 // The cookie expires in 15 minutes
  });

  // Return the JWT token and the refresh token
  return { token, refreshToken };
}

-- ─────────────────────────────────────────────────────────────────────────────


/**
 * @brief This function checks if there is an existing refresh token for the user and returns it if it exists. If not, it creates a new refresh token.
 * @param userId The user's ID.
 * @return An object containing the token and its expiration date.
 */
async refreshTokenIfNeeded(userId: number): Promise<{ token: string, expiresAt: Date }> {
  // Find the first refresh token that has not expired for the given user ID
  const existingRefreshToken = await this.prisma.refreshToken.findFirst({
    where: {
      userId: userId,
      expiresAt: {
        gte: new Date(), //greater or equal to the current date
      },
    },
  });

  // If an existing refresh token is found, return it
  if (existingRefreshToken) {
    return { token: existingRefreshToken.token, expiresAt: existingRefreshToken.expiresAt };
  } else {
    // If no existing refresh token is found, create a new one
    const newRefreshToken = await this.createRefreshToken(userId);
    return { token: newRefreshToken.token, expiresAt: newRefreshToken.ExpirationDate };
  }
}

-- ─────────────────────────────────────────────────────────────────────────────


  /**
   * @brief This function creates a refresh token.
   * @param userId The user's ID.
   * @return token: string, ExpirationDate: Date 
   */
  async createRefreshToken(userId: number): Promise<{ token: string, ExpirationDate: Date }> {
    const refreshToken = randomBytes(40).toString('hex'); // Generates a random 40-character hex string

    const expiration = new Date();
    expiration.setDate(expiration.getDate() + 7); // Set refreshToken expiration date within 7 days
    console.log(expiration);

    // Save refreshToken to database along with userId
    await this.prisma.refreshToken.create({
      data: {
        token: refreshToken,
        userId: userId,
        expiresAt: expiration
      }
    });

    return { token: refreshToken, ExpirationDate: expiration };
  }